#include "./imports/stdlib.fc";
#include "_compiled_code.fc";
cell ref_at(slice cell_, int index) impure asm "PLDREFVAR";
slice calculate_child_address(cell state_init) inline {
    return begin_cell().store_uint(1024, 11)
        .store_uint(cell_hash(state_init), 256)
        .end_cell()
        .begin_parse();
}
;; slice try_get_address(slice data, int index) {
;;     int status = data~load_uint(1 << 4);
;;     if (status & (1 << index)) {
;;         return null();
;;     }
;;     return data.ref_at(index).begin_parse();
;; }
int user_index(slice owner) inline {
    return owner~load_uint(1);
}
cell child_state_init(slice owner) inline {
    return begin_cell()
        .store_uint(6, 5)
        .store_ref(get_child_code())
        .store_ref(
            begin_cell()
                .store_slice(my_address())
            ;; stores one bit empty for cell
                .store_uint(
                    user_index(owner), 5
                )
                .end_cell()
        )
        .end_cell();
}
() deploy_child(slice data, slice old, int index) impure inline {
    ;; builder addr = begin_cell()
    ;;     .store_uint(1024, 11)
    ;;     .store_uint(cell_hash(state_init), 256);

    cell message = begin_cell()
        .store_slice(data)
        .store_slice(old)
        .store_uint(index, 256)
        .end_cell();
    send_raw_message(message, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);

}
(slice, ()) test_if_default(slice data) impure inline {
    if(slice_bits(data) == 64){
        return begin_cell()
            .store_uint((data~load_bits(64) % 32) << 64, 64 + 32)
            .end_cell()
            .begin_parse();
    }
    return data;
}
() recv_internal(cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_msg_flags();
    slice sender_address = cs~load_msg_addr();
    in_msg_body~load_op();
    if (flags & 1) {
        int istrue = in_msg_body~load_bool();
        slice data = get_data().begin_parse();
        if (istrue) {
            int a = data~load_uint(64) - 1;
            set_data(
                begin_cell()
                    .store_uint(a, 64)
                    .store_slice(data)
                    .end_cell()
            );
        }
        else {
            int a = data~load_uint(64 + 32) - 1;
            set_data(
                begin_cell()
                    .store_uint(a, 64 + 32)
                    .store_slice(data)
                    .end_cell()
            );
        }
        return ();
    }
    slice data = get_data().begin_parse();
    data~test_if_default();
    slice data2 = data;
    throw_unless(1394, now() <= data~load_uint(32));
    slice old = in_msg_body;
    int value = in_msg_body~load_uint(1);
    if (data2.slice_refs()) {
        data2~load_ref();
    }
    if (value) {
        int a = data2~load_uint(64) + 1;
        set_data(
            begin_cell()
                .store_uint(a, 64)
                .store_slice(data2)
                .end_cell()
        );
    }
    else {
        int a = data2~load_uint(64 + 32) + 1;
        set_data(
            begin_cell()
                .store_uint(a, 64 + 32)
                .store_slice(data2)
                .end_cell()
        );
    }
    (int __, int v) = parse_std_addr(sender_address);
    slice dataToSend = null();
    if (data.slice_refs()) {
        cell rrrr = data~load_ref();
        dataToSend = rrrr.begin_parse();
    }
    else {

        data~skip_bits( 64);
        dataToSend = data;
    }
    deploy_child(
        dataToSend,
        old,
        v
    );
}

_ proposalState() method_id {
    slice s = get_data().begin_parse();
    s~skip_bits(32);

    return (
        s~load_uint(32),
        s~load_uint(32)
    );
}
() __tact_selector_hack_asm() impure asm """
@atend @ 1 {
    execute current@ context@ current!
    {
        }END> b>

        <{
            SETCP0 DUP
            IFNOTJMP:<{
                DROP over <s ref@ 0 swap @procdictkeylen idict@ { "internal shortcut error" abort } ifnot @addop
            }>
swap <s ref@
            0 swap @procdictkeylen idict- drop
            -1 swap @procdictkeylen idict- drop
            65535 swap @procdictkeylen idict- drop

            @procdictkeylen DICTPUSHCONST DICTIGETJMPZ 11 THROWARG
        }> b>
    } : }END>c
    current@ context! current!
} does @atend !
""";
() __tact_selector_hack() method_id (65535) {
    return __tact_selector_hack_asm();
}
#include "./imports/stdlib.fc";
(slice, int) check_if_op_and_1(slice input) asm "x{00000001C_} SDBEGINSQ";
(slice, int) slice_stats_with_0_0(slice input) asm "<b 0 8 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_1_1(slice input) asm "<b 1 4 u, 1 4 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_0_1(slice input) asm "<b 0 4 u, 1 4 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_2_1(slice input) asm "<b 2 4 u, 1 4 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_2_2(slice input) asm "<b 2 4 u, 2 4 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_3_2(slice input) asm "<b 3 4 u, 2 4 u, b> <s SDBEGINSQ";
(slice, int) starts_with_3(slice input) asm "<b 3 2 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_4_2(slice input) asm "<b 4 4 u, 2 4 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_4_3(slice input) asm "<b 4 4 u, 3 4 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_5_3(slice input) asm "<b 5 4 u, 3 4 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_6_3(slice input) asm "<b 6 4 u, 3 4 u, b> <s SDBEGINSQ";
(slice, int) slice_stats_with_0_1(slice input) asm "<b 0 4 u, 1 4 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_0_2(slice input) asm "<b 0 4 u, 2 4 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_0_3(slice input) asm "<b 0 4 u, 3 4 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_0_4(slice input) asm "<b 0 4 u, 4 4 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_0_5(slice input) asm "<b 0 4 u, 5 4 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_0_6(slice input) asm "<b 0 4 u, 6 4 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_0_7(slice input) asm "<b 0 4 u, 7 4 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_0_8(slice input) asm "<b 0 4 u, 8 4 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_0(slice input) asm "<b 0 4 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_1(slice input) asm "<b 1 4 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_2(slice input) asm "<b 2 4 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_3(slice input) asm "<b 3 4 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_4(slice input) asm "<b 4 4 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_5(slice input) asm "<b 5 4 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_6(slice input) asm "<b 6 4 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_7(slice input) asm "<b 7 4 u, b> <s SDBEGINSQ";
(slice, int) slice_starts_with_8(slice input) asm "<b 8 4 u, b> <s SDBEGINSQ";
(slice, ()) check_if_starts_with_00(slice input) impure asm """
<b 0 8 u, b> <s SDBEGINSQ IFJMP:<{
    // data on the top
    // check that date is correct (load from data last 32 bits)
    // hardcode magic constant, which gonna compare with
    // submit solution after around 13-17 seconds after building
    DROP
    now 3600 24 * + 30 + PUSHINT
    // copare with now and throw error if...
    NOW GEQ 2 THROWIFNOT
    // check for bool in msg_body
    x{00000001C_} SDBEGINSQ IFJMP:<{
        <b 0 4 u, 1 4 u, b> PUSHREF c4 POPCTR
    }>
    <b 1 4 u, 0 4 u, b> PUSHREF c4 POP
}>
""";
(slice, ()) check_if_starts_with_01(slice input) impure asm """
    x{01} SDBEGINSQ
    IFJMP:<{
      s0 POP
      s0 s1 XCHG
      CTOS
      43 PUSHINT
      SDSKIPFIRST
      <b 3 2 u, b> <s SDBEGINSQ
      s1 POP
      1 THROWIF
      x{00000001C_} SDBEGINSQ
      // s1 POP
      <{
        <b 1 4 u, 1 4 u, 0 2 u, b> PUSHREF c4 POPCTR
      }> PUSHCONT
      IFNOTJMP
      <b 0 4 u, 2 4 u, b> PUSHREF
      c4 POPCTR
    }>

""";
(slice, ()) check_if_starts_with_22(slice input) impure asm """
<b 2 4 u, 2 4 u, b> <s SDBEGINSQ IFJMP:<{
    <b 3 4 u, 2 4 u, b> PUSHREF c4 POP
}>
""";
(slice, ()) check_if_starts_with_11(slice input) impure asm """
<b 1 4 u, 1 4 u, b> <s SDBEGINSQ IFJMP:<{
    <b 2 4 u, 1 4 u, b> PUSHREF c4 POP
}>
""";
int starts_with(slice a, slice b) asm "SDPFXREV";
const int size = 4; ;; btw it can be 44, 45 and more

(slice, ()) set_data_ifnot_msgbody_bool(slice in_msg_body) impure asm """
x{00000001C_} SDBEGINSQ IFNOTJMP:<{
    <b 1 4 u, 0 4 u, b> PUSHREF c4 POP
}>
""";
cell a0b1_c3() asm "<b 0 4 u, 1 4 u, 3 2 u, b> PUSHREF";
cell a1b1_c3() asm "<b 1 4 u, 1 4 u, 3 2 u, b> PUSHREF";
cell a1b1_c0() asm "<b 1 4 u, 1 4 u, 0 2 u, b> PUSHREF";
cell a0b2() asm "<b 0 4 u, 2 4 u, b> PUSHREF";
cell a0b3() asm "<b 0 4 u, 3 4 u, b> PUSHREF";
cell a0b4() asm "<b 0 4 u, 4 4 u, b> PUSHREF";
cell a0b5() asm "<b 0 4 u, 5 4 u, b> PUSHREF";
cell a0b6() asm "<b 0 4 u, 6 4 u, b> PUSHREF";
cell a0b7() asm "<b 0 4 u, 7 4 u, b> PUSHREF";
cell a0b8() asm "<b 0 4 u, 8 4 u, b> PUSHREF";
cell a0b9() asm "<b 0 4 u, 9 4 u, b> PUSHREF";
cell a0b10() asm "<b 0 4 u, 10 4 u, b> PUSHREF";
cell a1bo() asm "<b 1 4 u, 0 4 u, b> PUSHREF";
cell b1a1() asm "<b 1 4 u, 1 4 u, b> PUSHREF";
cell b1a2() asm "<b 2 4 u, 1 4 u, b> PUSHREF";
cell b2a2() asm "<b 2 4 u, 2 4 u, b> PUSHREF";
cell b2a3() asm "<b 3 4 u, 2 4 u, b> PUSHREF";
cell b2a4() asm "<b 4 4 u, 2 4 u, b> PUSHREF";
cell b3a4() asm "<b 4 4 u, 3 4 u, b> PUSHREF";
cell b3a5() asm "<b 5 4 u, 3 4 u, b> PUSHREF";
cell b3a6() asm "<b 6 4 u, 3 4 u, b> PUSHREF";
cell b4a6() asm "<b 6 4 u, 4 4 u, b> PUSHREF";
;;; adds 2 uin64 (containing 2 uint32)
() recv_internal(cell in_msg_full, slice in_msg_body) impure {
    ;; ifemptytopstackdie();
    ;; asm optimized way to check wheter it is the first call
    slice data2 = get_data().begin_parse();
    data2~check_if_starts_with_00();
    data2~check_if_starts_with_11();
    if (data2~slice_starts_with_0_1()) {
        slice c = in_msg_full.begin_parse();
        c~skip_bits(43);
        throw_if(1, c~starts_with_3());
        ifnot (in_msg_body~check_if_op_and_1()) {
            set_data(a1b1_c0());
            return ();
        }
        ;; increasing needed
        set_data(a0b2());
        return ();
    }
    if (data2~slice_starts_with_2_1()) {
        set_data(b2a2());
        return ();
    }
    data2~check_if_starts_with_22();
    if (data2~slice_starts_with_0_2()) {
        set_data(a0b3());
        return ();
    }
    if (data2~slice_starts_with_0_3()) {
        set_data(a0b4());
        return ();
    }
    if (data2~slice_starts_with_0_4()) {
        set_data(a0b5());
        return ();
    }
    if (data2~slice_starts_with_0_5()) {
        set_data(a0b6());
        return ();
    }
    if (data2~slice_starts_with_0_6()) {
        set_data(a0b7());
        return ();
    }
    if (data2~slice_starts_with_0_7()) {
        set_data(a0b8());
        return ();
    }
    if (data2~slice_starts_with_0_8()) {
        set_data(a0b9());
        return ();
    }
    if (data2~slice_starts_with_0()) {
        set_data(a0b10());
        return ();
    }
    if (data2~slice_starts_with_3_2()) {
        set_data(b2a4());
        return ();
    }
    if (data2~slice_starts_with_4_2()) {
        set_data(b3a4());
        return ();
    }
    if (data2~slice_starts_with_4_3()) {
        set_data(b3a5());
        return ();
    }
    if (data2~slice_starts_with_5_3()) {
        set_data(b3a6());
        return ();
    }
    if (data2~slice_starts_with_6_3()) {
        set_data(b4a6());
        return ();
    }
    throw(123);
}

_ proposalState() method_id (-14) {
    slice s = get_data().begin_parse();
    return (
        s~load_uint(size),
        s.preload_uint(size)
    );
}


() __tact_selector_hack_asm() impure asm """
@atend @ 1 {
    execute current@ context@ current!
    {
        }END> b>
        <{
            // method code, in_msg_body
            IFNOTJMP:<{
                DUP SEMPTY IFJMP:<{ }>
                over <s ref@ 0 swap @procdictkeylen idict@ { "internal shortcut error" abort } ifnot @addop
            }>
swap <s ref@
            -14 swap @procdictkeylen idict@ { "internal shortcut error" abort } ifnot @addop
        }> b>
    } : }END>c
    current@ context! current!
} does @atend !
""";

() __tact_selector_hack() method_id (65535) {
    return __tact_selector_hack_asm();
}